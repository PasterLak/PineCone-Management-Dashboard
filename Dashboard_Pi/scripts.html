<script>
function escapeHtml(s) {
  return (s ?? '').replace(/[&<>"']/g, m => ({
    '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
  }[m]));
}

function parseTS(ts) {
  return new Date(ts);
}

const tbody = document.getElementById('tbody');
let prevDevices = window.initialDevices || {};

function render(devices) {
  const prev = prevDevices;
  const rows = Object.entries(devices).map(([id, d]) => ({
    id,
    ip: d.ip,
    description: d.description || '',
    last_seen: d.last_seen,
    ts: parseTS(d.last_seen)
  }));

  rows.sort((a, b) => b.ts - a.ts);

  const frag = document.createDocumentFragment();

  for (const r of rows) {
    const tr = document.createElement('tr');
    tr.dataset.id = r.id;

    const descCellHtml = `
      <td class="desc-cell" data-id="${r.id}">
        <span class="desc-text">${escapeHtml(r.description)}</span>
        <button class="edit-btn" type="button">✏️</button>
      </td>
    `;

    tr.innerHTML = `
      <td>${r.id}</td>
      <td>${r.ip}</td>
      ${descCellHtml}
      <td>${r.last_seen}</td>
    `;

    const was = prev[r.id];
    if (!was || was.last_seen !== r.last_seen) {
      tr.classList.add('flash');
      tr.addEventListener('animationend', () => tr.classList.remove('flash'), { once: true });
    }

    const diffMs = Date.now() - r.ts.getTime();
    if (diffMs > 5000) {
      tr.classList.add('offline');
    }

    frag.appendChild(tr);
  }

  tbody.replaceChildren(frag);
  prevDevices = devices;
}

if (window.initialDevices) {
  render(window.initialDevices);
}

let activeCell = null;

document.addEventListener('click', (e) => {
  const okBtn = e.target.closest('.ok-btn');
  const cancelBtn = e.target.closest('.cancel-btn');
  const editBtn = e.target.closest('.edit-btn');

  if (okBtn) {
    finishEdit(okBtn.closest('.desc-cell'), false);
    return;
  }
  if (cancelBtn) {
    finishEdit(cancelBtn.closest('.desc-cell'), true);
    return;
  }
  if (editBtn) {
    startEdit(editBtn.closest('.desc-cell'));
    return;
  }
});

function startEdit(cell) {
  if (!cell || activeCell === cell) return;
  activeCell = cell;

  const textEl = cell.querySelector('.desc-text');
  const currentText = textEl ? textEl.textContent.trim() : '';

  const input = document.createElement('input');
  input.type = 'text';
  input.value = currentText;
  input.className = 'desc-input';

  const okBtn = document.createElement('button');
  okBtn.className = 'ok-btn';
  okBtn.type = 'button';
  okBtn.textContent = '✅';

  const cancelBtn = document.createElement('button');
  cancelBtn.className = 'cancel-btn';
  cancelBtn.type = 'button';
  cancelBtn.textContent = '❌';

  cell.dataset.old = currentText;
  cell.replaceChildren(input, okBtn, cancelBtn);

  input.focus();
  input.select();

  input.addEventListener('keydown', (ev) => {
    if (ev.key === 'Enter') finishEdit(cell, false);
    if (ev.key === 'Escape') finishEdit(cell, true);
  });
}

function finishEdit(cell, cancel = false) {
  const nodeId = cell.dataset.id;
  const input = cell.querySelector('.desc-input');
  const oldText = cell.dataset.old || '';
  const newText = cancel ? oldText : (input ? input.value.trim() : oldText);

  renderText(cell, newText);
  activeCell = null;

  if (cancel || newText === oldText) return;

  fetch('/api/update_description', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ node_id: nodeId, description: newText })
  })
  .then(r => (r.ok ? r.json() : Promise.reject(r)))
  .catch(err => {
    console.error('Update failed:', err);
    renderText(cell, oldText);
    alert('Speichern fehlgeschlagen.');
  });
}

function renderText(cell, text) {
  const span = document.createElement('span');
  span.className = 'desc-text';
  span.textContent = text;

  const editBtn = document.createElement('button');
  editBtn.className = 'edit-btn';
  editBtn.type = 'button';
  editBtn.textContent = '✏️';

  cell.replaceChildren(span, editBtn);
}

window.socket = window.socket || io();
window.socket.on('update', (payload) => {
  if (payload && payload.devices) {
    render(payload.devices);
  }
});

function tickOffline() {
  const now = Date.now();
  const rows = tbody.querySelectorAll('tr');
  for (const tr of rows) {
    const id = tr.dataset.id;
    const d = prevDevices[id];
    if (!d) continue;
    const ts = parseTS(d.last_seen).getTime();
    if (now - ts > 5000) {
      tr.classList.add('offline');
    } else {
      tr.classList.remove('offline');
    }
  }
}

tickOffline();
setInterval(tickOffline, 1000);
</script>
