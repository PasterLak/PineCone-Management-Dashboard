<script>
(() => {
  // --- Konfiguration / Konstanten ---
  const OFFLINE_THRESHOLD_MS = 5_000;
  const TICK_OFFLINE_INTERVAL_MS = 1_000;
  const POLL_INTERVAL_MS = 1_000;

  // --- DOM-Referenzen ---
  const tbody = document.getElementById('tbody');

  // --- State ---
  const state = {
    prevDevices: window.initialDevices || {},
    activeCell: null,
    isEditing: false,
  };

  // --- Hilfsfunktionen ---
  function toRows(devices) {
    return Object.entries(devices).map(([id, d]) => ({
      id,
      ip: d.ip,
      description: d.description || '',
      last_seen: d.last_seen,
      ts: new Date(d.last_seen).getTime(),
    }));
  }

  function createRow(row, now) {
    const tr = document.createElement('tr');
    tr.dataset.id = row.id;
    tr.innerHTML = `
      <td>${row.id}</td>
      <td>${row.ip}</td>
      <td class="desc-cell" data-id="${row.id}">
        <span class="desc-text">${row.description}</span>
        <button class="edit-btn" type="button">✏️</button>
      </td>
      <td>${row.last_seen}</td>
    `;

    // Flash Zeile bei Änderung von last_seen
    const was = state.prevDevices[row.id];
    if (!was || was.last_seen !== row.last_seen) {
      tr.classList.add('flash');
      tr.addEventListener('animationend', () => tr.classList.remove('flash'), { once: true });
    }

    // Offline-Markierung
    if (now - row.ts > OFFLINE_THRESHOLD_MS) {
      tr.classList.add('offline');
    }

    return tr;
  }

  // --- Rendering der Tabelle ---
  function render(devices) {
    const rows = toRows(devices).sort((a, b) => b.ts - a.ts);
    const frag = document.createDocumentFragment();
    const now = Date.now();

    for (const row of rows) {
      frag.appendChild(createRow(row, now));
    }

    tbody.replaceChildren(frag);
    state.prevDevices = devices;
  }

  // --- Description-Editing ---
  function startEdit(cell) {
    if (!cell || state.activeCell === cell) return;
    state.activeCell = cell;
    state.isEditing = true;

    const currentText = (cell.querySelector('.desc-text')?.textContent || '').trim();

    const input = document.createElement('input');
    input.type = 'text';
    input.value = currentText;
    input.className = 'desc-input';

    const okBtn = document.createElement('button');
    okBtn.className = 'ok-btn';
    okBtn.type = 'button';
    okBtn.textContent = '✅';

    const cancelBtn = document.createElement('button');
    cancelBtn.className = 'cancel-btn';
    cancelBtn.type = 'button';
    cancelBtn.textContent = '❌';

    cell.dataset.old = currentText;
    cell.replaceChildren(input, okBtn, cancelBtn);

    input.focus();
    input.select();

    input.addEventListener('keydown', (ev) => {
      if (ev.key === 'Enter') finishEdit(cell, false);
      if (ev.key === 'Escape') finishEdit(cell, true);
    });
  }


  function renderText(cell, text) {
    const span = document.createElement('span');
    span.className = 'desc-text';
    span.textContent = text;

    const editBtn = document.createElement('button');
    editBtn.className = 'edit-btn';
    editBtn.type = 'button';
    editBtn.textContent = '✏️';

    cell.replaceChildren(span, editBtn);
  }

  function finishEdit(cell, cancel) {
    const nodeId = cell.dataset.id;
    const input = cell.querySelector('.desc-input');
    const oldText = cell.dataset.old || '';
    const newText = cancel ? oldText : (input ? input.value.trim() : oldText);

    renderText(cell, newText);
    state.activeCell = null;
    state.isEditing = false;

    if (cancel || newText === oldText) return;

    fetch('/api/update_description', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ node_id: nodeId, description: newText }),
    })
      .then((r) => (r.ok ? r.json() : Promise.reject(r)))
      .catch(() => {
        renderText(cell, oldText);
        alert('Speichern fehlgeschlagen.');
      });
  }


  // --- Offline-Status regelmäßig aktualisieren ---
  function updateOfflineStatus() {
    const now = Date.now();
    const rows = tbody.querySelectorAll('tr');

    for (const tr of rows) {
      const d = state.prevDevices[tr.dataset.id];
      if (!d) continue;
      const ts = new Date(d.last_seen).getTime();

      if (now - ts > OFFLINE_THRESHOLD_MS) {
        tr.classList.add('offline');
      } else {
        tr.classList.remove('offline');
      }
    }
  }

  // --- Polling der Devices vom Server ---
  function pollDevices() {
    fetch('/api/devices')
      .then((r) => (r.ok ? r.json() : Promise.reject(r)))
      .then((data) => {
        if (data && data.devices) {
          if (state.isEditing) {
            state.prevDevices = data.devices;
          } else {
            render(data.devices);
          }
        }
      })
      .catch((err) => {
        console.error('Polling failed', err);
      });
  }


  // --- Events ---
  function bindDomEvents() {
    document.addEventListener('click', (e) => {
      const okBtn = e.target.closest('.ok-btn');
      const cancelBtn = e.target.closest('.cancel-btn');
      const editBtn = e.target.closest('.edit-btn');

      if (okBtn) {
        finishEdit(okBtn.closest('.desc-cell'), false);
      } else if (cancelBtn) {
        finishEdit(cancelBtn.closest('.desc-cell'), true);
      } else if (editBtn) {
        startEdit(editBtn.closest('.desc-cell'));
      }
    });
  }

  // --- Initialisierung ---
  function init() {
    // Initiale Daten aus serverseitigem Rendern (sofortige Anzeige)
    if (window.initialDevices) {
      render(window.initialDevices);
    }

    // DOM-Events binden
    bindDomEvents();
    // Offline-Status Ticker starten
    updateOfflineStatus();
    setInterval(updateOfflineStatus, TICK_OFFLINE_INTERVAL_MS);

    // Polling starten
    pollDevices();
    setInterval(pollDevices, POLL_INTERVAL_MS);
  }

  // Start der App
  init();
})();
</script>
