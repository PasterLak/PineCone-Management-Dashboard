<script>
  (() => {
    // --- Konfiguration ---
    const OFFLINE_THRESHOLD_MS = 5_000;
    const TICK_OFFLINE_INTERVAL_MS = 1_000;
    const POLL_INTERVAL_MS = 1_000;

    // --- DOM-Referenzen ---
    const sidebar = document.getElementById("sidebar");
    const sidebarToggle = document.getElementById("sidebarToggle");
    const sidebarItems = document.querySelectorAll(".sidebar-item");
    const pages = document.querySelectorAll(".page");

    const tbody = document.getElementById("tbody");

    // --- State ---
    const state = {
      prevDevices: window.initialDevices || {},
      activeCell: null,
      isEditing: false,
      isSidebarOpen: false,
      currentPage: "home",
    };

    // ---------- PAGE SWITCHING (Fade) ----------
    function showPage(name) {
      state.currentPage = name;

      // Sidebar-Active-Status aktualisieren
      sidebarItems.forEach((item) => {
        const target = item.dataset.target;
        item.classList.toggle("sidebar-item--active", target === name);
      });

      // Seiten ein-/ausblenden mit Fade
      pages.forEach((page) => {
        const pageName = page.dataset.page;
        const isActive = pageName === name;
        page.classList.toggle("page--active", isActive);
      });

      feather.replace();
    }

    function initSidebar() {
      if (!sidebar || !sidebarToggle) return;

      sidebarToggle.addEventListener("click", () => {
        state.isSidebarOpen = !state.isSidebarOpen;
        sidebar.classList.toggle("sidebar--open", state.isSidebarOpen);
        sidebar.classList.toggle("sidebar--closed", !state.isSidebarOpen);

        feather.replace();
      });

      sidebarItems.forEach((item) => {
        item.addEventListener("click", () => {
          const target = item.dataset.target;
          if (!target) return;
          showPage(target);
        });
      });

      // Klick außerhalb schließt Sidebar
      document.addEventListener("click", (event) => {
        if (!state.isSidebarOpen) return;

        const clickedSidebar = event.target.closest("#sidebar");
        const clickedToggle = event.target.closest("#sidebarToggle");
        if (!clickedSidebar && !clickedToggle) {
          state.isSidebarOpen = false;
          sidebar.classList.remove("sidebar--open");
          sidebar.classList.add("sidebar--closed");
          feather.replace();
        }
      });
    }

    // ---------- DASHBOARD / GERÄTE ----------
    // Falls kein Dashboard-Table existiert (andere Seite): Dashboard-Code überspringen
    if (!tbody) {
      initSidebar();
      feather.replace();
      return;
    }

    function toRows(devices) {
      return Object.entries(devices).map(([id, d]) => ({
        id,
        ip: d.ip,
        description: d.description || "",
        last_seen: d.last_seen,
        ts: new Date(d.last_seen).getTime(),
      }));
    }

    function createRow(row, now) {
      const tr = document.createElement("tr");
      tr.dataset.id = row.id;
      tr.innerHTML = `
      <td>${row.id}</td>
      <td>${row.ip}</td>
      <td class="desc-cell" data-id="${row.id}">
        <span class="desc-text">${row.description}</span>
        <button class="edit-btn" type="button" aria-label="Edit description">
          <i data-feather="edit-3"></i>
        </button>
      </td>
      <td>${row.last_seen}</td>
    `;

      const was = state.prevDevices[row.id];
      if (!was || was.last_seen !== row.last_seen) {
        tr.classList.add("flash");
        tr.addEventListener(
          "animationend",
          () => tr.classList.remove("flash"),
          { once: true }
        );
      }

      if (now - row.ts > OFFLINE_THRESHOLD_MS) {
        tr.classList.add("offline");
      }

      return tr;
    }

    function render(devices) {
      const rows = toRows(devices).sort((a, b) => b.ts - a.ts);
      const frag = document.createDocumentFragment();
      const now = Date.now();

      for (const row of rows) {
        frag.appendChild(createRow(row, now));
      }

      tbody.replaceChildren(frag);
      state.prevDevices = devices;

      feather.replace();
    }

    // --- Description Editing ---
    function startEdit(cell) {
      if (!cell || state.activeCell === cell) return;
      state.activeCell = cell;
      state.isEditing = true;

      const currentText = (
        cell.querySelector(".desc-text")?.textContent || ""
      ).trim();

      const input = document.createElement("input");
      input.type = "text";
      input.value = currentText;
      input.className = "desc-input";

      const okBtn = document.createElement("button");
      okBtn.className = "ok-btn";
      okBtn.type = "button";
      okBtn.setAttribute("aria-label", "Save description");
      okBtn.innerHTML = `<i data-feather="check"></i>`;

      const cancelBtn = document.createElement("button");
      cancelBtn.className = "cancel-btn";
      cancelBtn.type = "button";
      cancelBtn.setAttribute("aria-label", "Cancel edit");
      cancelBtn.innerHTML = `<i data-feather="x"></i>`;

      cell.dataset.old = currentText;
      cell.replaceChildren(input, okBtn, cancelBtn);

      input.focus();
      input.select();

      input.addEventListener("keydown", (ev) => {
        if (ev.key === "Enter") finishEdit(cell, false);
        if (ev.key === "Escape") finishEdit(cell, true);
      });

      feather.replace();
    }

    function renderText(cell, text) {
      const span = document.createElement("span");
      span.className = "desc-text";
      span.textContent = text;

      const editBtn = document.createElement("button");
      editBtn.className = "edit-btn";
      editBtn.type = "button";
      editBtn.setAttribute("aria-label", "Edit description");
      editBtn.innerHTML = `<i data-feather="edit-3"></i>`;

      cell.replaceChildren(span, editBtn);

      feather.replace();
    }

    function finishEdit(cell, cancel) {
      const nodeId = cell.dataset.id;
      const input = cell.querySelector(".desc-input");
      const oldText = cell.dataset.old || "";
      const newText = cancel ? oldText : input ? input.value.trim() : oldText;

      renderText(cell, newText);
      state.activeCell = null;
      state.isEditing = false;

      if (cancel || newText === oldText) return;

      fetch("/api/update_description", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ node_id: nodeId, description: newText }),
      })
        .then((r) => (r.ok ? r.json() : Promise.reject(r)))
        .catch(() => {
          renderText(cell, oldText);
          alert("Speichern fehlgeschlagen.");
        });
    }

    function updateOfflineStatus() {
      const now = Date.now();
      const rows = tbody.querySelectorAll("tr");

      for (const tr of rows) {
        const d = state.prevDevices[tr.dataset.id];
        if (!d) continue;
        const ts = new Date(d.last_seen).getTime();

        if (now - ts > OFFLINE_THRESHOLD_MS) {
          tr.classList.add("offline");
        } else {
          tr.classList.remove("offline");
        }
      }
    }

    function pollDevices() {
      fetch("/api/devices")
        .then((r) => (r.ok ? r.json() : Promise.reject(r)))
        .then((data) => {
          if (data && data.devices) {
            const newDevices = data.devices;
            if (state.isEditing) {
              // Wenn editiert wird, nur den Snapshot aktualisieren, aber nicht neu rendern.
              state.prevDevices = newDevices;
            } else {
              // Nur neu rendern, wenn sich last seen oder die IDs geändert haben
              const prev = state.prevDevices || {};
              const prevIds = new Set(Object.keys(prev));
              const newIds = Object.keys(newDevices);

              const idsChanged =
                newIds.length !== Object.keys(prev).length ||
                newIds.some((id) => !prevIds.has(id));

              const lastSeenChanged = newIds.some((id) => {
                const p = prev[id];
                const n = newDevices[id];
                return !p || p.last_seen !== n.last_seen;
              });

              if (idsChanged || lastSeenChanged) {
                render(newDevices);
                return;
              }
            }
          }
        })
        .catch((err) => {
          console.error("Polling failed", err);
        });
    }

    function bindDomEvents() {
      document.addEventListener("click", (e) => {
        const okBtn = e.target.closest(".ok-btn");
        const cancelBtn = e.target.closest(".cancel-btn");
        const editBtn = e.target.closest(".edit-btn");

        if (okBtn) {
          finishEdit(okBtn.closest(".desc-cell"), false);
        } else if (cancelBtn) {
          finishEdit(cancelBtn.closest(".desc-cell"), true);
        } else if (editBtn) {
          startEdit(editBtn.closest(".desc-cell"));
        }
      });
    }

    function init() {
      if (window.initialDevices) {
        render(window.initialDevices);
      }

      bindDomEvents();
      initSidebar();
      showPage("home");

      updateOfflineStatus();
      setInterval(updateOfflineStatus, TICK_OFFLINE_INTERVAL_MS);

      pollDevices();
      setInterval(pollDevices, POLL_INTERVAL_MS);

      feather.replace();
    }

    init();
  })();
</script>
